#!/usr/bin/env perl
# Manage turn sequence in The Fantasy Trip's Melee/Wizard
# Copyright (C) 2021 David P. Rideout
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
use strict;
use warnings; # It is not easy to turn off only uninitialized value in join or string warnings (7jan022)
use List::Util qw/max/;
# use List::MoreUtils qw/firstidx any/;

# Setting flags
my $debug = 0; # 1 ==> max debug output
my $initiative = 'c'; # c ==> character-based; PARTY ==> party-based
                      # PLAYER ==> player-based; SIDE ==> 'side-based
my $xpRate = 10; # minutes per wallclock time xp (12 is standard)
                # prime factors of 60: 2 2 3 5
# Catch signals
$SIG{INT} = sub { print "\nINT signal received, exiting.\nCheck your log files to ensure you do not lose your history.\n"; close LOG; exit; };

# Check settings
die "Invalid initiative setting" unless $initiative =~ /^(c|PARTY|PLAYER|SIDE)$/;
# die "Side-based initiative is not implemented yet\n" unless $initiative =~ /^[cpl]$/;
# die "Only character- party-based initiative is currently implemented\n" unless $initiative =~ /^[cpl]$/;
# die "Only character-based initiative is currently implemented\n" unless $initiative =~ /^[c]$/;
# Side-based initiative is problematic -- I need to add it to the UI somehow.  Should be a property of parties.  Could group the input parties somehow on the command line?  Or maybe better -- have each party file declare a side name at the top! (2AUG021)


# Banner
print 'MElee/Wizard COmbat SeQuence tool  Copyright (C) 2021  David P. Rideout
This program comes with ABSOLUTELY NO WARRANTY.
This is free software, and you are welcome to redistribute it under the
conditions of the GNU GENERAL PUBLIC LICENSE Version 3; see LICENSE file.
';
# This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
#     This is free software, and you are welcome to redistribute it
#     under certain conditions; type `show c' for details.
print "\n";

# Check command line
my $restart;
if (@ARGV) {
  while ($ARGV[0]) {
#     print "first arg: [$ARGV[0]]\n";
    last unless $ARGV[0] =~ /^\-([ld]+)$/;
    my $options = $1;
    $restart = 1 if $options =~ /l/;
    $debug = 1 if $options =~ /d/;
    $debug && print "options: $options\n";
    shift @ARGV;
  }
}
die "Usage: mewcosq [-ld] <party 1> [party 2] [party 3] ...\n" .
    "  -l ==> restart from log file\n" .
    "  -d ==> debug mode\n" unless @ARGV;
$debug && print "Debug level $debug\n\n";

# Data structures
# ---------------
my @characters; # val hash with below keys
my %charkeys; # key namekey val index into @characters
my %hkeys = (NAME=>1, ST=>1, STrem=>1, DX=>1, adjDX=>1, PLAYER=>1, PARTY=>0, STUN=>0, FALL=>0, StunTurn=>0, DEAD=>0, NAMEKEY=>0, BAD=>1, ROPE=>0, ADJ=>0, CREATOR=>1, SIDE=>1);
# STUN how much damage causes stun
# StunTurn becomes unstunned on this turn
# FALL how much damage causes fall
# 1 ==> can appear in party file
# I almost never use %hkeys.  Is it worth maintaining? (27oct021)
my $n = 0; # total number of characters
my @xp; # indexed by char, value array of pairs num, description
my @spellRenewalxp; # add it all up for each character
my %sides; # key SIDE val num characters (only used for display at the beginning (8nov021))
# my $ncommands=0; # number of user entered commands
my @history; # save history for ud
my @ent2chr; # character index for each entity index, used only for displaying characters in initiative order for character-based initiative (7jan022)

# Read parties
# ------------
foreach my $partyfile (@ARGV) {
  unless (open FP, '<', $partyfile) {
    open FP, '<', "parties/$partyfile" or die "Error opening $partyfile: $!\n";
  }
  $partyfile =~ s/^.*\/([^\/]+)$/$1/; # strip directories/ off party names
  print "Reading party file $partyfile:\n";
  my %globals; # key global variable val value
  my @hkeys; # header keys
  while (<FP>) {
    # clean line
    next if /^#/;
    next unless /[^\s]/; # ignore pure-whitespace lines
    chomp;
    s/\r//; # get rid of dos line endings
    # check for double spaces
    print "Warning: adjacent spaces. Tab rendered as spaces?\n" if /  /;

    # parse valid line
    if (/^(\w+)\s*=\s*(.*)$/) { # global variable
      die "invalid line: $_" unless defined $hkeys{$1};
      if ($1 eq 'SIDE') { print "reading side $2...\n"; }
      elsif ($1 eq 'PARTY') { print "reading party $2...\n"; }
      $globals{$1} = $2;
      next;
    }

    # read header of key names
    unless (@hkeys) {
      @hkeys = split /\t/;
      # Check that all headers are valid
      foreach (@hkeys) { die "Unrecognized field: $_\n" unless $hkeys{$_} }
      die "Unique NAME required for each character" unless defined $hkeys{NAME};
      next;
    }

    # read character lines
    my @l = split /\t/;
    die "Can't have multiple headers in party file: $_" if $l[0] eq $hkeys[0];
    # Is this a good enough check? (27nov021)
    my $c = {};
    foreach my $i (0..$#hkeys) {
      $debug && print "$hkeys[$i] = $l[$i]\n";
      $c->{$hkeys[$i]} = $l[$i] }
    print $n+1, "\t$c->{NAME}\n";
    foreach my $g (keys %globals) { $c->{$g} = $globals{$g} }
    if (defined $c->{SIDE}) { ++$sides{$c->{SIDE}} }
    elsif ($initiative eq 'SIDE') { die "Please provide SIDE for each party when using side-based-initiative\n" }
    # Will anyone ever have adjDX = 0??
    die if $c->{adjDX} eq 0;
    $c->{adjDX} = $c->{DX} unless $c->{adjDX};
    
    # Check some field values
    die "Please provide adjDX for $c->{NAME}.\n" unless $c->{adjDX};
    die "Please provide ST for each character.\n" unless $c->{ST};
    die "Please provide DX for each character.\n" unless $c->{DX};
    #     my $nhex = $c->{NHEX};
    #     die "Can only handle 1 or 3 hex characters currently\n"
    # 	unless $nhex==1 || $nhex==3;
    $c->{PARTY} = $partyfile unless defined $c->{PARTY};
    $characters[$n++] = $c;
  }
  close FP;
}
my $nsides = keys %sides;
print "\n$n characters and $nsides side", &s($nsides), ":\n";
foreach my $side (sort {$sides{$b} <=> $sides{$a}} keys %sides) {
  print "$sides{$side}\t$side\n";
}
print "\n";
print 'Using ', $initiative eq 'c' ? 'CHARACTER':$initiative,
    "-based movement initiative.\n";

# Preparations
# ------------
foreach my $ci (0..$#characters) { character_prep($ci); }

# Open log file
# -------------
my @log;
my $seed;
my $startTime;
if ($restart) {
  open LOG, '<log/log' or die "problem reading log file";
  chomp($seed = <LOG>);
  chomp($startTime = <LOG>);
  srand $seed;
  @log = <LOG>;
  close LOG;
} else {
  $startTime = time;
  $seed = srand;
#   print "\nOverwrite log.bak file? (interrupt (Ctrl-C) if not!)"; <STDIN>;
}
if (-f 'log') {
  print "log file exists -- moving to new log file directory\n";
  `mv -f log junk`;
  `mkdir log`;
  `mv junk log/log`;
  `mv -n log* log`;
} elsif (not -d 'log') { `mkdir log` }
# print "log dir\n" if -d 'log';
my $bakn = 0; # backup number
++$bakn while -e "log/log$bakn";
system "mv log/log log/log$bakn"; # mv is faster that cp on same filesystem (12sep021)

open LOG, '>log/log' or die "problem creating log file";
print LOG "$seed\n";
print LOG "$startTime\n";
push @history, $seed, $startTime;

# Manage combat sequence
# ======================
my $turn = 0;
my $phase = ''; # Combat sequence phase
my @turn_damage; # amt damage sustained this turn for each character
my @acted; # who acted so far this turn, -1 ==> deferred action
my %retreats; # possible forced retreats  key forcer val hash key forced
my @dxact; # amt to add to adjDX for this turn due to chosen action
my @dxspl; # amt to add to adjDX for this turn due to others' actions
# Blur spell would go into @dxact -- it is my choice to attack the blurred figure.
my @dxinj; # amt to add to adjDX due to injury
my @roll; # action initiative roll, indexed by character index
my @distMoved; # how far each character moved during the movement phase
my $maxdx; # adjDX of acting character
my $ndefer = 0; # num deferred characters
my $continue; # holds chari of figure which has another action, else undef

print "\nCapital letter is default option for each prompt\n\n";

# Main loop
while (1) {
  # Surprise
  my %surprise_parties;
  unless ($turn) {
    my $q = query('n', 'Surprise? (y)es (N)o');
    if ($q eq 'y') {
      # Generate list of suprised parties
      # I assume no one can be dead yet?
      ++$surprise_parties{$_->{PARTY}} foreach @characters;
      # no don't use an array.  Leave the surprised parties in a hash.
#       my @surprise_parties = keys %parties;
      foreach (sort keys %surprise_parties) { #my $i (0..$#surprise_parties) {
# 	$q = query('y', "Is $surprise_parties[$i] surprised? (Y)es (n)o");
# 	splice @surprise_parties, $i, 1 unless $q eq 'y';
	$q = query('y', "Is $_ surprised? (Y)es (n)o");
	delete $surprise_parties{$_} unless $q eq 'y';
      }
      # Below if !$turn && $surprise_parties{...PARTY} then skip that character
#       die "If no parties are surprised then please accept the default '(N)o' for  the 'Surprise?' question\n" unless keys %surprise_parties;
    } else { ++$turn; }
  }

  print "\n* Turn $turn:\n";

  # Movement
  # --------
  my @entities; # = (); I think this is not needed? (7jan022)
  @distMoved = ();
  @ent2chr = ();
  if ($initiative eq 'c') {
#     foreach my $c (@characters) {
    foreach my $ci (0..$n-1) {
      my $c = $characters[$ci];
      next unless $turn || !$surprise_parties{$c->{PARTY}};
      unless ($c->{DEAD}) {
	push @entities, $c->{NAME};
	push @ent2chr, $ci;
      }
    }
  }
  else {
#     my $type = 'PARTY';
#     $type = 'PLAYER' if $initiative eq 'l';
    my %entities;
    foreach my $c (@characters) {
      next unless $turn || !$surprise_parties{$c->{PARTY}};
      next if $c->{DEAD};
      my $ent = $c->{$initiative};
      push @entities, $ent unless $entities{$ent}++;
    }
  }
  die "There is no one available to move!\n" unless @entities;
  movement(@entities);
  
  # Actions
  # -------
  print "\nAction phase:\n";
  
  # Declare expected dex adjustments and other special considerations
  my @poles; # pole weapon charges
  my @bow2;  # double bow attacks
  @dxact = (0) x $n;
  @dxspl = (0) x $n;
  @dxinj = (0) x $n;

  # Apply ongoing dxmods
  foreach my $ci (0..$#characters) {
    my $c = $characters[$ci];
    next if $c->{DEAD};

    # waiting for an opening
    $dxspl[$_] += $c->{WAIT} if $c->{WAIT};

    # other mods
    my $mods = $characters[$ci]->{ADJ};
    next unless $mods;
    my $i=0;
    print "i=$i mods=[@{$mods}]\n";
    my ($mod, $lastTurn) = $mods->[$i..$i+1];
    $lastTurn = $turn if $lastTurn eq 'inf';
    if ($lastTurn < $turn) { splice @$mods, $i, 2 }
    else { $dxspl[$ci] += $mod }
  }
  
  $phase = 'action consideration';
  &displayCharacters();
  print 'Special considerations: <who> <consideration1> [consideration2]
  Considerations are
  * <adj>
    DEX adjustments as offset from original declared adjDX.  
    Ignore reactions to injury and weapon range penalties.
  * <c|b>
    c ==> pole weapon charge
    b ==> double shot with bow
  e.g. "2 -4 p" for char 2 doing rear attack as pole weapon charge
  * sh<adj>
    \'Permanently\' ready or unready a shield
';
  while (1) {
    my $sccmd = query('', "(F)inished");
    last unless $sccmd;
    my @sccmd = split / +/, $sccmd; # special considerations cmd
    my $who = who(shift @sccmd);
    next if $who eq 'x';
    print "$characters[$who]->{NAME}";
    foreach my $cmd (@sccmd) {
      if ($cmd =~ /^\+?-?\d+$/) { #(\+|-) ?(\d+)( ?([pm]))?/) {
	$dxact[$who] += $cmd;
	my $plus = '+';
	$plus = '' if $cmd =~ /^[\+-]/;
	print " at $plus$cmd DEX = ", $characters[$who]->{adjDX}+$cmd, ' (- injury adjustments)';
      } elsif ($cmd eq 'c') {
	push @poles, $who;
	print " charging with pole weapon";
      } elsif ($cmd eq 'b') {
	push @bow2, $who;
	print " double shot with bow";
      } elsif (shield($characters[$who], $cmd)) {}
      else { print "\nUnrecognized consideration [$cmd]\n"; }
    } # loop over considerations for this character
    print "\n";
  } # special considerations
  print "\n";

  # Compute dx mods due to injury or Rope spell
  for my $i (0..$n-1) {
    my $chr = $characters[$i];
    
#     $dex[$i] = $chr->{adjDX};
#     $dex[$i] += $dexadj[$i] if $dexadj[$i]; # (it might be undefined!)

    # Reactions to injury
    $dxinj[$i] = -2 if $turn < $chr->{StunTurn};
#     $dex[$i] -= 3 if $chr->{STrem} < 4;
    # I have to keep track of the two different types of damage for wizards (7aug021)
    $dxinj[$i] -= 3 if $chr->{BAD} && $chr->{STrem} < 4;
#     print "$chr->{NAME} dxinj = $dxinj[$i]\n";
    my $ropeTurn = $chr->{ROPE};
    $dxspl[$i] -= 2 + $turn - $ropeTurn if $ropeTurn;
  }

  # Act
  my @chars = 0..$n-1;
  $phase = 'action';
  unless ($turn) { # prune surprised characters
    $debug && print "pruning surprised characters\n";
    foreach (my $i=$#chars; $i>=0; --$i) { # ($#chars..0) {
      splice @chars, $i, 1 if $surprise_parties{$characters[$i]->{PARTY}};
#       $debug && print "prunned suprised character $characters[$i]
    }
  }
      
  @turn_damage = ();
  @acted = ();
#   @damaged = (); # who has taken damage this turn
  %retreats = (); # possible forced retreats (I think perl is smart about
                  # freeing each hash value? (3sep021))
  
  if (@poles) {
    $phase = 'pole weapon charges';
    print "Pole weapon charges:\n";
    act(@poles);
    # It is not necessary to remove the poles.  They will have @acted so will get skipped anyway.
  }
  $phase = 'normal actions';
  print "\nNormal attacks:\n";
  act(@chars);
  if (@bow2) {
    # remove acted flag from living chars
    !$characters[$_]->{DEAD} && (@acted[$_] = 0) foreach @bow2;
    $phase = 'second missle shots';
    print "\nSecond bow attacks:\n";
    $debug && print "for @bow2\n";
    act(@bow2);
  }

  # Force Retreats
  # Any figure which has inflicted attack hits on an
  #   adjacent figure and has not taken damage this turn may execute a forced
  #   retreat on the adjacent figure.  (Attack hits include any physical attack
  #   and missle spells.)
  $phase = 'forced retreats';
  print "\nPossible Forced Retreats: (if two chacters are adjacent)\n";
  print "None.\n" unless keys %retreats;
  foreach my $forcer (keys %retreats) {
    $debug && print "considering forcer $forcer\n";
    next if $turn_damage[$forcer];
    foreach my $forced (keys %{$retreats{$forcer}}) {
      next if $characters[$forced]->{DEAD};
      print "$characters[$forcer]->{NAME} on $characters[$forced]->{NAME}?\n";
    }
  }
  
  ++$turn;
}


# Display characters
sub displayCharacters {
  my @roll = @_; # map {defined $_ ? $_ : 0} @_; map should not be needed
  # pad @roll above to fill in gaps for dead characters?
  my $msg = 'Characters';
#   my @order = 0..$n-1;
  my @order = 0..$#roll;
  if ($initiative eq 'c' && @roll) {

#     This is confused.  @roll uses *entity* indices, not *character* indices!  I am conflating the two.  This needs to be clearer.
# 
# 	&movement is pased only a list of entities.
# 	the mapping of these to characters has to also be passed in!
    
    $debug && print "roll: @roll\n";
    $msg = 'Initiative order';
    @order = sort {return 0 unless $roll[$a] && $roll[$b];
		   $roll[$a]<=>$roll[$b]} 0..$#roll;
  }

#   print "roll: @roll\n";
  print '-'x26, "\n$msg:\n";
  for my $i (@order) {
    my $c = $characters[$ent2chr[$i]]; # $i];
    $debug && print "$i\t$ent2chr[$i]\t";
    print "$c->{NAMEKEY}\t$c->{NAME}\n" unless $c->{DEAD};
  }
  print '-'x26, "\n";
}


# Interact with user
# args: default value, query string
sub query {
#   my $default = shift;
#   my $query = shift;
#   my ($default, $query) = (@_);
  my ($default, $query) = @_;
  my %global_options = ('?'=>'n', c=>'l', q=>'n', ud=>'n'); #, d=>l); # l ==> log; n ==> no log

  while (1) {
    #   print "Turn $turn $phase: ", shift, ' or (q)uit> ';
#     print "Turn $turn $phase: ", $query, ' or global option, (?) for list> ';
    print "Turn $turn $phase: ", $query, ' or (?) for glbl opts> ';
    my $input;
    if ($restart && @log) {
      print $input = shift @log;
      chomp $input;
    }
    else { chomp($input = <STDIN>); }
    #   print "input is [$input]\n";
    #   print LOG "$input\n" unless $input eq 'q';
    #     my $cmd = substr $input, 0, 1;
    $input =~ s/^\s+//; # strip leading whitespace
    my @cmd = split / /, $input;
    my $cmd = $cmd[0];
    unless ($cmd && $global_options{$cmd} && $global_options{$cmd} eq 'n') {
      $debug && print "logging [$cmd]\n";
      print LOG "$input\n";
      push @history, $input;
#       ++$ncommands;
    }
    return $default unless $input || $input eq '0';

    # Process global options
    if ($global_options{$cmd}) {
      if ($input eq 'q') {
	print "Battle finished.\n";
	&xp; # if @xp;
	&finalST;
	exit;
      }
      if ($input eq '?') {
	print "(c <who> <DXmod>) to change <who>'s action to new <DXmod>\n", 
	    #(d <who> <DX mod>) to adjust <who>\'s DX by <DX mod>;
	    "(ud <n>) to undo n previous entries\n",
	    "or (q) to quit\n";
      }
      elsif ($input =~ /^c (.+) +?([-\d]+)$/) {
	my $whoi = who($1);
	next if $whoi eq 'x';
# 	my $c = $characters[$whoi];
	print "$characters[$whoi]->{NAME} changes action from DX mod ", smod($dxact[$whoi]), " to ",
	    smod($2), "\n";
	$dxact[$whoi] = $2;
	# I hope this is not the acting character.  If it is, just do the adjustment in your head!
	return 'de' if $2>0; # someone else's DX has increased -- it may not be my turn anymore
      }
      elsif ($input =~ /^ud (\d+)$/) {
	print "undoing previous $1 commands and restarting...\n\n";
	if ($1>@history) {
	  print "There have only been ", 0+@history, " commands so far!\n";
	  next;
	}
	close LOG;
	# 	++$bakn;
	my $cmd = 'mv log/log log/log' . ++$bakn;
	$debug && print "$cmd\n";
	system $cmd;
	open LOG, '>log/log' or die "problem creating log file";
	splice @history, -$1;
	print LOG "$_\n" for @history;
	close LOG;
# 	system "head -n -$1 log/log > log/log$bakn";
# 	system 'mv .junk log';
	exec "./mewcosq -l @ARGV";
      } else { print "error in global option [$input]\n"; }
    } else { return $input; }
  }
  
  #   $input;
  'error'; # should never get here?
}


# Output final ST (for ongoing campaign)
sub finalST {
  print "ST remaining:\n";
  print "------------\n";
  # Lot's of questions about how to handle this, including what to do about wizards. (22nov021)
  my $nwounded;
  foreach my $c (@characters) {
    next if $c->{STrem} < 1 || $c->{STrem} == $c->{ST};
    print "$c->{ST} ($c->{STrem})\t$c->{NAME}\n";
    ++$nwounded;
  }
  print "All survivors unharmed.\n" unless $nwounded;
}


# Output experience points
# (separate function simply because I don't want to put this code into the
#  &query parser under 'q' (28sep021))
sub xp {
  # Which sides won?
#   for my $i (0..$n-1) {
#     my $c = $characters[$i];
#     my $st = $c->{STrem};
#     $sides{$c->{SIDE}} = 'w' if $st>1;
#   }
  foreach my $c (@characters) {
    $c->{SIDE} = '' unless $c->{SIDE};
    $sides{$c->{SIDE}} = 'w' if $c->{STrem} > 1;
  }
  my $unconsciousXP = 0;
  my ($nwinners, $nunconscious) = (0)x2;
  foreach my $c (@characters) {
    if ($sides{$c->{SIDE}} eq 'w' && $c->{STrem} > 0) { ++$nwinners }
    elsif ($sides{$c->{SIDE}} ne 'w' && $c->{STrem} == 1) {
      $unconsciousXP += $c->{DX}+1; ++$nunconscious
    }
  }
  my $uxp = int($unconsciousXP/$nwinners+.5);
  print "$unconsciousXP xp from $nunconscious figures distributed evenly among $nwinners victors: $uxp xp each\n" if $nunconscious;
  
  # Wallclock xp
  my $seconds = time - $startTime;
  if ($seconds<121) { print "\n$seconds seconds" }
  elsif ($seconds < 7201) { print "\n", int($seconds/60+.5)." minutes" }
  else { my $hrs = int($seconds/3600);
# 	 $seconds -= $hrs*3600;
	 print "\n$hrs hours and ", int(($seconds-$hrs*3600)/60+.5)." minutes" }
  print " of wallclock time passed.\n";
  return unless @xp || @spellRenewalxp || $seconds>359;
  my $timexp = int($seconds/($xpRate*60) + .5);
  print "Each survivor earns (at least) $timexp xp for wallclock time.\n";

  # Print final results
  print "\nExperience points earned:\n",
        "------------------------\n";
  foreach my $ci (0..$n-1) {
    my $srxp = $spellRenewalxp[$ci];
    my $c = $characters[$ci];
    my $wuxp = $sides{$c->{SIDE}} eq 'w' ? $uxp : 0;
    $debug && print "$characters[$ci]->{NAME}\tsrxp=$srxp timexp=$timexp\n";
    next unless $timexp || $xp[$ci] || $srxp || $wuxp;
    next if $c->{DEAD} && $c->{STrem} != 1;
    push @{$xp[$ci]}, $srxp, 'spell renewal' if $srxp;
    push @{$xp[$ci]}, $wuxp, 'winner bonus' if $wuxp;
    print "$c->{NAME}:\n";
    my $tot = 0;
    while (my ($amt, $desc) = splice @{$xp[$ci]}, 0, 2) {
      print "$amt\t$desc\n";
      $tot += $amt;
    }
    print "$tot\tTotal\n";
    $tot += $timexp;
    print "$tot\tTotal (with time xp included)\n\n";
  }
}


# Character preparations
# How are these declarations working?  Don't they have to appear above?? (28aug021)
# my $uniquify = 0;
my $msg_space; # Did we output a message about spaces in character names?
my %namekeys; # key character val char index or hash of next level of %namekeys ...
sub character_prep {
  my $ci = shift;

  # Stun & fall thresholds
  my $char = $characters[$ci];
  my $st = $char->{ST};
  die "ST is not numeric.  tab vs space issue in party file?\n" if $st =~ /[^\d]/;
  if ($st < 30) { $char->{STUN} = 5; $char->{FALL} = 8; } # normal
  elsif ($st < 50) { $char->{STUN} = 9; $char->{FALL} = 16; } # giants
  else { $char->{STUN} = 15; $char->{FALL} = 25; } # dragons
  $char->{STrem} = $st unless $char->{STrem};
  $char->{StunTurn} = 0;
  if (!$char->{BAD} && $char->{ST}>$char->{STrem} && $char->{STrem}<4) {
    print "Assuming $char->{NAME} is at -3 DX due to injuries.  If not, please add a BAD column with 0 for this character.\n";
    $char->{BAD} = 1;
  }
  
  # Address some potential issues with names
  print "Replacing spaces with underscores in names\n"
      if $char->{NAME} =~ s/ /_/g && !$msg_space++;
  my $name = $char->{NAME};
#   print "WARNING: Numeric character specifications are considered as namekeys before character indices.  Character index specifications are deprecated. (20aug021)\n" if $name =~ /^\d/;
  
  # Name keys
#   my $namekey = extend_namekey($ci, '', \%namekeys);
  extend_namekey($ci, '', \%namekeys);
  
#   my $len = 1;
#   my $length = length $name;
#   my $namekey = substr $name, 0, $len;
#   $namekey = substr $name, 0, ++$len while $len <= $length && defined $charkeys{$namekey};
#   if ($len > $length) {
#     print "WARNING: namekey overflow.  Please use longer or more unique names.\n";
#     $namekey .= $uniquify++;
#   }
  # Is this good enough, or do I need to expand both keys? (27jul021)
  # Actually this could be better, e.g. if two people have the same first name.

#   if (defined $namekey) {
#     $charkeys{$namekey} = $ci;
#     $char->{NAMEKEY} = $namekey;
#   }
}


# Increments namekey (and all others implied by the new addition
sub extend_namekey {
#   my $whoi = shift;    # character index to extend
#   my $namekey = shift; # namekey so far I guess
#   my $nextLetter = shift; # root in %namekeys ?
  my ($whoi, $namekey, $nextLetter) = (@_);
  
  my $name = $characters[$whoi]->{NAME};
  my $lkey = length $namekey;
  my $lname = length $name;

  my $letter = substr $name, $lkey, 1;

  $debug && print "extend_namekey($whoi, $namekey, $nextLetter): name=$name lkey=$lkey lname=$lname letter=$letter\n";
#   $namekey = substr $name, 0, ++$lkey;
  #   unless ($nextLetter->{substr $namekey, -1, 1}) {
  delete $charkeys{$namekey}; # Can I do this globally like this?
  $namekey .= $letter;
  my $whatsThere = $nextLetter->{$letter}; # I think this creates $nextLetter if it is an undef
  if (! defined $whatsThere) { # namekey is not used yet
    $debug && print "Valid namekey $namekey found for char $whoi: $name\n";
    $nextLetter->{$letter} = $whoi;
    #     return $namekey
    $charkeys{$namekey} = $whoi;
    $characters[$whoi]->{NAMEKEY} = $namekey;
#     return $namekey; # . $letter;
  }
  elsif (! ref $whatsThere)  { # single character uses this namekey currently
    die "Two characters with identical names! $name\n" if $name eq $characters[$whatsThere]->{NAME};
    # I used to be able to uniquify them.  Restore that? (28aug021)

    my @expandNamekeys;
#     push @expandNamekeys, $nextLetter->{$letter}, $whoi;
    push @expandNamekeys, $whatsThere, $whoi;
    $nextLetter->{$letter} = {}; # change its char index value into a new hashref, as new root

    foreach (@expandNamekeys) {
      # remove this old namekey from %charkeys
#       delete $charkeys{$namekey};
    
#       my $nk = extend_namekey($_, $namekey, $nextLetter->{$letter});
#       $charkeys{$nk} = $_;
#       $characters[$_]->{NAMEKEY} = $nk;
      extend_namekey($_, $namekey, $nextLetter->{$letter});

      # How do I want to handle this?? -- let's do everything inline
    }
  } else { # multiple characters' namekey begins with this string
    #     foreach (keys %$nextLetter) { ???
    # Keep going (?)
#     $namekey .= $letter;
    extend_namekey($whoi, $namekey, $whatsThere);
  }
    
#   $namekey = substr $name, 0, ++$len while $len <= $length && defined $charkeys{$namekey};

  # What to do about overflow??
#   if ($len > $length) {
#     print "WARNING: namekey overflow.  Please use longer or more unique names.\n";
#     $namekey .= $uniquify++;
#   }
}


# Who is next to act?
sub whosnext {
  my $maxroll;
  my $next;

  return $continue if defined $continue;
  $maxdx = -99; # global so it can be used in &act
  $debug && print join(':', @roll), "\n";
  foreach (@_) {
    my $c = $characters[$_];
    next if $acted[$_] || $c->{DEAD};
    $debug && print "maxdx = $maxdx maxroll=$maxroll\n";
    my $dx = $characters[$_]->{adjDX} + $dxact[$_] + $dxspl[$_] + $dxinj[$_];
    if ($dx > $maxdx) {
      $next = $_;
      $maxdx = $dx;
      $maxroll = $roll[$_];
    } elsif ($dx == $maxdx && $roll[$_] > $maxroll) {
      $next = $_;
      $maxroll = $roll[$_];
    }
  }
  $debug && print "$next is next\n";
  $next;
}


# Signed modifier
sub smod { $_[0]<0 ? $_[0] : "+$_[0]" }

# Act in order of dex
# Pass array of characters who will act
sub act {
#   $debug && print join(':', @_), " passed to &act\n";
  my @chars = @_;
#   $debug && print join(':', @_), " is chars\n";
#   my $nchars = @chars;
  
  # Preparations
  #   foreach my $i (keys %{$chars}) {
  for my $ci (@chars) {
#   my $i = -1;
#   while (++$i < $nchars) { #(0..$#chars) {
#     $debug && print join(':', @_), " is chars beginning $i\n";
#     $debug && print join(':', @chars), " is chars beginning $i\n";
#     my $ci = $chars[$i]; # character index
#     $debug && print "chars[$i] = $ci\n";
    die unless defined $ci; # not too sure what is happening here (15sep021)
    # Roll initiative
    $roll[$ci] = rand; # I think it is safer to roll for everybody... (20sep021)
#     $debug && print "i=$i ci=$ci roll=$roll[$ci]\n";

#     if ($acted[$ci] || $characters[$ci]->{DEAD}) {
#       # I think this prunning is probably silly? (20sep021)
#       $debug && print "pruning at i=$i, ci=$ci\n";
#       splice @chars, $i, 1;
#       --$nchars;
# #       next;
#     }
#     $debug && print join(':', @_), " is chars end $i\n";
  }
  
  # Actions
  &displayCharacters();
  print "Actions:\n",
        "-------\n", # in alphabetical order (within each sub-phase)
      "* [sp<ST>] <who>-<dam>\n  (e.g. c-4 for 4 damage to character c after armor)\n",
      "* de [DX mod]\t\t\tdefer action\n",
      "* m\t\t\tmiss (to end wait-for-an-opening)\n";
#   print "* sp<ST> a <who> <DX mod>\n  spell which modifies <who>\'s adjDX by <DX mod>\n",
  print "* a <who> <DX mod> <num turns>\n  adjust <who>\'s adjDX by <DX mod>\n",
      "  Use spell convention for num turns, so 0 for this-turn-only.\n  Use inf for 'permanent' change to adjDX, such as from readying a shield.\n",
      "  (e.g. 'sp3 a x -6 3' for Clumsiness spell on x)\n",
      "* sp<ST> <name> <ST> <DX> [adjDX]\n  create being\n", # create being
      "* di <who>\t\tdisbelieve <who>\n",
      "* sp2 r <who>\t\tcast Rope spell on <who>\n",
      "* [sp<ST>] sh<dex adj>\tready or unready shield, which changes base adjDX\n",
	  "\t\t\t(e.g. 'sh -2' to ready a tower shield)\n",
      "* ur <who>\t\tun-Rope <who>\n",
      "* w\t\t\twait for an opening\n",
      "  Prefix with 'sp<ST>' if result is from spell of ST cost <ST>.\n",
      "  (Note that spell can have no result, but still cost ST.)\n",
      "  Suffix with '\\' if figure has more actions for this turn.\n"
      if $phase =~ /normal/;
  print '-' x 79, "\n";
  my $act_chari;
#   print 0+@chars, " chars @ START\n";
  while (defined ($act_chari = whosnext(@chars))) {
#     print 0+@chars, " chars\n";
    my $ac = $characters[$act_chari]; # acting character
    die if $ac->{DEAD}; # &whosnext should not return dead figures
    print "$ac->{NAME}: ST $ac->{ST} ($ac->{STrem})  adjDX $ac->{adjDX} ",
	smod($dxinj[$act_chari]), 'inj ', smod($dxact[$act_chari]), 'act ',
	smod($dxspl[$act_chari]), "spl = $maxdx";
    print " (stunned until turn $ac->{StunTurn})" if $turn < $ac->{StunTurn};
    # Stunned 'through this turn' or '... next turn'? (12aug021)
    print "  Moved $distMoved[$act_chari] hexes" if defined $distMoved[$act_chari];
    print "\n";

    # Action query loop for character with index $act_chari
    my $defer;
    while (1) {
      my $action = query('', "Action result? (N)o");
      $debug && print "act_chari=$act_chari action=[$action]\n";

      # Spell cost
      if ($action =~ s/^sp ?(\d+)\s*//) {
	next unless spendST($ac, $1);
# 	$ac->{STrem} -= $1;
	print "$ac->{NAME} casts spell, has $ac->{STrem} ST remaining\n";
	push @{$xp[$act_chari]}, $1, "$1 ST spell" unless defined $ac->{CREATOR};
      }

      # Continue?
      if ($action =~ s/\s*\\\s*$//) {
	$continue = $act_chari;
	print "$ac->{NAME} may have another action\n";
      } else { undef $continue }
      
      # Result of action (in alphabetical order after Hit-for-damage)
      last unless $action && lc $action ne 'n';
      if (shield($ac, $action)) { last; } # must precede Hit
      elsif ($action =~ /^a (.+) (-?\d+) (\d+|inf)$/) {  # adjust DX
	my $targeti = who($1);
	next if $targeti eq 'x';
	if ($targeti == $act_chari) {
	  print "Are you really trying to change your adjDX as your own action?  Please use de?\n";
	  next;
	}
	my $mod = $2;
	my $dur = $3;
	$dxspl[$targeti] += $mod;
	if ($dur) {
	  $dur = $turn+$dur unless $dur eq 'inf';
# 	  my @mod_entry = $mod, $dur;
# 	  print "pushing [@mod_entry] to adj array\n";
	  push @{$characters[$targeti]->{ADJ}}, $mod, $dur;
	      #$mod, $dur eq 'inf' ? 'inf':$turn+$dur;
	}
	print "$characters[$targeti]->{NAME} adjDX ", smod($2), " for $3 turns\n";
	last;
      } # DX mod, e.g. from Clumsiness spell
      elsif ($action =~ /^([^ ]+) (\d+) (\d+) ?(\d+)?$/) { # Create being
	my ($name, $st, $dx, $adjdx) = ($1, $2, $3, $4);
	$adjdx = $dx unless defined $adjdx;
	print "$name created with ST $st DX $dx ($adjdx)\n";
	print "Animals get automatic disbelieve roll\n";
	# Not too sure how to handle this.  Will write explicit code for now, but should put into function which is shared with 'Read parties' code above. (29jul021)
	$characters[$n]->{NAME} = $name;
	$characters[$n]->{ST} = $st;
	$characters[$n]->{STrem} = $st;
	$characters[$n]->{DX} = $dx;
	$characters[$n]->{adjDX} = $adjdx;
	$characters[$n]->{PLAYER} = $characters[$act_chari]->{NAME};
	$characters[$n]->{PARTY} = $characters[$act_chari]->{PARTY};
	$characters[$n]->{CREATOR} = $act_chari;
	push @dxact, 0;
	push @dxspl, 0;
	push @dxinj, 0;
	character_prep($n++);
	&displayCharacters();
	delete $ac->{WAIT};
	last; # always last after successful action result
      } # create being
      elsif ($action =~ /^de ?([\d+-]+)?/) { # Defer action
	$dxact[$act_chari] = $1 if defined $1;
	$defer = -1;
	++$ndefer;
	last;
      }
      elsif ($action =~ /^di (.+)$/) { # Disbelieve
	my $who = who($1);
	next if $who eq 'x';
	$characters[$who]->{DEAD} = 1;
	$acted[$who] = 1;
	print "Disbelieve $characters[$who]->{NAME}\n";
	my $who_xp = $act_chari;
	$who_xp = $ac->{CREATOR} if defined $ac->{CREATOR};
	push @{$xp[$who_xp]}, 10, "disbelieve $characters[$who]->{NAME}";
	delete $ac->{WAIT};
	last;
      }
      elsif ($action eq 'm') { # Miss (to end wait-for-an-opening)
	delete $ac->{WAIT};
	last;
      }
      elsif ($action =~ /^r (.+)$/) { # Rope spell
	my $whoi = who($1);
	next if $whoi eq 'x';
	$characters[$whoi]->{ROPE} = $turn;
	$dxinj[$whoi] -= 2;
	print "Cast Rope on $characters[$whoi]->{NAME}\n";
	delete $ac->{WAIT};
	last;
      }
      elsif ($action =~ /^ur (.+)$/) { # un-Rope
	my $whoi = who($1);
	next if $whoi eq 'x';
	delete $characters[$whoi]->{ROPE};
	print "un-Rope $characters[$whoi]->{NAME}\n";
	delete $ac->{WAIT};
	last;
      }
      elsif ($action eq 'w') { # wait for an opening
	++$ac->{WAIT};
	$ac->{WAIT} = 2 if $ac->{WAIT} > 2;
	print "wait for an opening, +$ac->{WAIT} DX\n";
	last;
      }
      elsif ($action =~ /(.+) ?- ?(\d+)/) { # Hit!
	delete $ac->{WAIT}; # miss also deletes wait for an opening!!
	$debug && print "Hit!\n";
	my $injuredi = who($1);
	next if $injuredi eq 'x';
	print "Injuring self!\n" if $injuredi == $act_chari;
	my $dc = $characters[$injuredi]; # damaged character
	my $damage = $2;
	$debug && print "$characters[$act_chari]->{NAME} hits $characters[$injuredi]->{NAME} for $damage damage\n";
	++$retreats{$act_chari}->{$injuredi};
	  
	# Reaction to Injury
	my $died;
	print "$damage ST damage to $dc->{NAME}\n";
	$dc->{STrem} -= $damage;
	my $old_turn_damage = $turn_damage[$injuredi];
	$old_turn_damage = 0 unless defined $old_turn_damage;
	$turn_damage[$injuredi] += $damage;
	print "$dc->{NAME} has taken $turn_damage[$injuredi] damage so far this turn, has $dc->{STrem} ST remaining\n";
	my $turn_damage = $turn_damage[$injuredi];
	if ($turn_damage >= $dc->{STUN}) { # && $dc->{StunTurn} <= $turn) {
	  print "$dc->{NAME} is stunned\n";
	  $dxinj[$injuredi] -= 2 if $dc->{StunTurn} <= $turn;
	  $dc->{StunTurn} = $turn+2;
	}
	$debug && print "turn_damage=$turn_damage  FALL=$dc->{FALL}  old_turn_damage=$old_turn_damage\n";
	if ($turn_damage >= $dc->{FALL} && $old_turn_damage < $dc->{FALL}) {
	  print "$dc->{NAME} falls down\n";
	  $acted[$injuredi] = 1;
	}
	if ($dc->{STrem} <4 && $dc->{STrem}+$damage >3) {
	  print "$dc->{NAME} is in bad shape...\n";
	  ++$dc->{BAD};
	  $dxinj[$injuredi] -= 3;
	}
	if ($dc->{STrem} <2) {
	  $dc->{DEAD} = 1;
	  if ($dc->{STrem} == 1) {print "$dc->{NAME} falls unconscious\n";}
	  else { $died=1; print "$dc->{NAME} dies\n"; }
	  $acted[$injuredi] = 1;
	}
	# XP value
	my $who_xp = $act_chari;
	$who_xp = $ac->{CREATOR} if defined $ac->{CREATOR};
	if ($died) {
	  push @{$xp[$who_xp]}, $dc->{STrem}+$damage+$dc->{DX}, "killed $dc->{NAME}";
	  # damage added because it has been subtracted from STrem already (19sep021)
	} else {
	  push @{$xp[$who_xp]}, $damage, "$damage hits on $dc->{NAME}";
	}

	last; # exit from while (1) action query loop
      } # did damage
      else { print "Unrecognized action $action\n"; }
    } # what happened during $act_chari's action
    $debug && print "ndefer=$ndefer  before \@acted: ", join(':', @acted), "\n";
    if ($defer) { $acted[$act_chari] = -1; }
    else {
      $debug && print "$ac->{NAME} acted  ndefer=$ndefer\n";
      --$ndefer if $acted[$act_chari] && $acted[$act_chari] < 0; # if this was a deferred figure
      if ($ndefer) {
	# clear all defer flags
	# 	foreach my $i (0..$#acted) { $acted[$i] = 0 if $acted[$i] < 0; }
	my $i = 0;
	while ($ndefer--) {
	  while (!$acted[$i] || $acted[$i]>0) { ++$i;
# 				  print "$ndefer $i $acted[$i]\n"; <STDIN>;
	  }
	  $acted[$i] = 0;
	  ++$i;
	}
	$ndefer = 0; # maybe i should use different logic above (28sep021)
      } # \exists deferred queue
      $acted[$act_chari] = 1;
    } # acted
    $debug && print 'after @acted: ', join(':', @acted), "\n";

  } # loop over actors
  $debug && print "actions finished\n";
} # main loop over turns



# Change shield state
# pass char ref and input string
# returns true if input changes shield state
sub shield {
#   my $c = shift;
#   my $input = shift;
  my ($c, $input) = (@_);
  
  if ($input =~ /^sh ?([\d-]+)$/) { # change shield state
    my $adjDX = $c->{adjDX};
    print $1>0 ? ' un' : ' ', "readies shield: adjDX $adjDX --> ", $adjDX+$1, "\n";
    $c->{adjDX} += $1;
    1;
  } else { 0; }
}


# Intiative, spell renewal, & movement
# pass me an array of alive (string) entities
sub movement {
  my @ent = @_;
  
  # Roll Initiative
  # ---------------
  my @roll; # = ..$n; # movement initiative roll, indexed by entity
  # Padding @roll causes lots of problems.
#   if ($initiative eq 'c') {
#     for (my $i=0; $i<$n; ++$i) { $roll[$i] = rand }
    # &displayCharacters needs roll for each character.  Maybe displaying initiative via &displayCharacters is a mistake... (22nov021)
#   } else {
  for (my $i=0; $i<@ent; ++$i) { $roll[$i] = rand; } #}

  my $displayInitiative = ($initiative ne 'c' or !$turn);
  print "\nInitiative order:\n" if $displayInitiative; #unless $initiative eq 'c';
  my @order;
  my $prev_roll;
  my @moved; # who has moved so far
  foreach my $i (sort {$roll[$a] <=> $roll[$b]} 0..$#roll) {
    my $roll = $roll[$i];
    if (defined $prev_roll && $prev_roll == $roll) { die "Roll collision!\n"; }
    else { $prev_roll = $roll; }
    print " $ent[$i]\n" if $displayInitiative; #unless $initiative eq 'c';
    push @order, $i;
  }
#   print "\n";

  $phase = 'renew spells';
  my $fmt = "format: <who> <cost>\n    or: di <who>  to discontinue created figure\n";
  @roll = () unless $turn;
  displayCharacters(@roll);
  print "Spell renewal phase: Renew spells and discontinue creations\n$fmt";
  while (1) {
    my $sccmd = query('', 'Spell cost, (F)inished,');
    last unless $sccmd;
    my @sccmd = split / /, $sccmd;
    #     unless $sccmd =~ /^([^
    if ($sccmd[0] eq 'di') {
      my $whoi = who(pop @sccmd);
      next if $whoi eq 'x';
      my $c = $characters[$whoi];
      print "$c->{NAME} disappears\n";
      $c->{DEAD} = 1;
    } else {
      my $whoi = who(shift @sccmd);
      my $cost = shift @sccmd;
      next if $whoi eq 'x';
      if ($cost !~ /^\d+$/) {
	print "Please use positive integer for ST cost $cost\n", $fmt; next; }
      elsif (@sccmd) { print $fmt; next; } # there are further cmds remaining
      my $c = $characters[$whoi];
      next unless spendST($c, $cost);
      print "$c->{NAME} has $c->{STrem} ST remaining\n";
      $spellRenewalxp[$whoi] += $cost unless defined $c->{CREATOR};
    }
  }
  
  # Movement
  # --------
  my $i = 0;
  my $last = $#ent; # queue index of last in queue
  my $defer; # who to defer to
  my $q = 1; # query user?

  $phase = 'movement';
  print "\nMovement phase: ";
  if ($initiative eq 'c') {
#     &displayCharacters;
    print "Enter number of hexes moved at prompt\n",
	"d <who>  ALL defer until <who> (just match leading symbols)\n";
#     $w = ' <who>';
  } else { print "Enter '0' to move\n"; }

  $debug && print "\@order: @order\n";
  
  while (1) {
    # skip over people who have gone already
    while ($moved[$order[$i]]) {
      $debug && print "skipping over moved character $order[$i]\n";
      ++$i
    }

    my $moveri = $order[$i];    
    if ($i == $last) {
#       print "$ent[$order[$i]] moves\n";
      my $nhexes = query(0, "$ent[$order[$i]] moves,"); # to get num hexes
      $moved[$order[$i]] = 1;
      $distMoved[$moveri] = $nhexes if $initiative eq 'c';
      $defer = undef; # Right?  Can't defer past end of queue? (3nov021)
      $q = 1;
      $i = 0;
      while ($last>=0 && $moved[$order[--$last]]) {}
    } else {
      my $move = 'd';
      my $who = $ent[$order[$i]];
      $debug && print "order[$i]=$order[$i] last=$last defer=", defined($defer)?$defer:'', "\n";
      if (defined $defer) {
	if ($who =~ /^$defer/) {
	  $defer = undef;
# 	  print "who matches!\n";
	  $q = 1;
# 	  $i = 0;
	} else { $q = 0 }
      }
#       $move = query('d', "$who move, (D$w)efer, (f)inished,") if $q;
      $move = query('d', "$who move, (D)efer, (f)inished,") if $q;
      
      # Parse move
      if ($move =~ /^\d/) { # digit ==> move
	$moved[$order[$i]] = 1;
	--$last if $i==$last;
	$i = 0;
	$distMoved[$moveri] = $move if $initiative eq 'c';
      }
      elsif ($move =~ /^d ?(.+)?$/) { # defer (till <who>)
	if (defined $1) {
	  $defer = $1;
	  print "All defer until $1\n";
	}
	++$i;
      }
      elsif ($move eq 'f') { last; } # finished
      else { print "unrecognized response [$move]\n"; }
    }
    last if $last<0;
  } # movement phase
  $debug && print "[$initiative] distMoved: ", join('|', @distMoved), "\n";
}


# Spend spell ST
# args: char_handle, amt_spent
# returns true on success
# Outputs error message on error, but none on success
sub spendST {
  my $c = shift;
  my $cost = shift;
  my $st = $c->{STrem};

  # Check if overspent
  if ($cost > $st) {
    print "$c->{NAME} only has $st ST remaining.  Try again.\n";
    return 0;
  }

  $c->{STrem} -= $cost;
  if ($c->{STrem} <= 1) {
    print "$c->{NAME} falls unconscious\n";
    $c->{DEAD} = 1;
    print "$c->{NAME} dies -- Is this intentional??!\n" if $c->{STrem} < 1;
  }
  1;
}


# Returns character index to whom a string refers
# 'x' on error
sub who {
  my $s = shift;
#   my $retval = $charkeys{$s};

#   if (defined $retval) { return $retval; }
  my $l = length $s;
  while ($l) {
    my $retval = $charkeys{substr $s, 0, $l--};
    if (defined $retval) { return $retval; }
  }
#   elsif ($s =~ /^\d/) {
#     if ($s<0 || $s >= $n) { return -2; }
#     return $s;
  #   }
  # It would be nice to handle errors directly here somehow. (28aug021)
  print "Invalid character specification '$s'\n";
  'x'; # should be an invalid array index
}


# s to pluralize word?
sub s { shift > 1 ? 's' : '' }
